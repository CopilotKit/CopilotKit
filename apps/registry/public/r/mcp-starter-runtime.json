{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "mcp-starter-runtime",
  "type": "registry:block",
  "title": "MCP Starter Runtime",
  "description": "A runtime for CopilotKit with MCP.",
  "dependencies": [
    "@copilotkit/runtime",
    "@modelcontextprotocol/sdk"
  ],
  "files": [
    {
      "path": "registry/quickstarts/mcp-starter/runtime.ts",
      "content": "import {\n  CopilotRuntime,\n  OpenAIAdapter,\n  copilotRuntimeNextJSAppRouterEndpoint,\n} from \"@copilotkit/runtime\";\nimport { NextRequest } from \"next/server\";\nimport { MCPClient } from \"@/registry/quickstarts/mcp-starter/utils/mcp-client\";\n\nconst serviceAdapter = new OpenAIAdapter();\nconst runtime = new CopilotRuntime({\n  createMCPClient: async (config) => {\n    const mcpClient = new MCPClient({\n      serverUrl: config.endpoint,\n    });\n    await mcpClient.connect();\n    return mcpClient;\n  },\n});\n\nexport const POST = async (req: NextRequest) => {\n  const { handleRequest } = copilotRuntimeNextJSAppRouterEndpoint({\n    runtime,\n    serviceAdapter,\n    endpoint: \"/api/copilotkit\",\n  });\n\n  return handleRequest(req);\n};\n",
      "type": "registry:lib",
      "target": "app/api/copilotkit/route.ts"
    },
    {
      "path": "registry/quickstarts/mcp-starter/utils/mcp-client.ts",
      "content": "import { MCPTool, MCPClient as MCPClientInterface } from \"@copilotkit/runtime\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport type { JSONRPCMessage } from \"@modelcontextprotocol/sdk/types.js\";\n\nexport interface McpClientOptions {\n  serverUrl: string;\n  headers?: Record<string, string>;\n  onMessage?: (message: Record<string, unknown>) => void;\n  onError?: (error: Error) => void;\n  onOpen?: () => void;\n  onClose?: () => void;\n}\n\n/**\n * McpClient - A Model Context Protocol client implementation\n *\n * This class implements the Model Context Protocol (MCP) client, which allows for\n * standardized communication with MCP servers. It's designed to be compatible with\n * CopilotKit's runtime by exposing the required interface.\n *\n * The main methods required by CopilotKit are:\n * - tools(): Returns a map of tool names to MCPTool objects\n * - close(): Closes the connection to the MCP server\n */\nexport class MCPClient implements MCPClientInterface {\n  private client: Client;\n  private transport: SSEClientTransport;\n  private serverUrl: URL;\n  private onMessage: (message: Record<string, unknown>) => void;\n  private onError: (error: Error) => void;\n  private onOpen: () => void;\n  private onClose: () => void;\n  private isConnected = false;\n  private headers?: Record<string, string>;\n\n  // Cache for tools to avoid repeated fetches\n  private toolsCache: Record<string, MCPTool> | null = null;\n\n  constructor(options: McpClientOptions) {\n    this.serverUrl = new URL(options.serverUrl);\n    this.headers = options.headers;\n    this.onMessage =\n      options.onMessage ||\n      ((message) => console.log(\"Message received:\", message));\n    this.onError =\n      options.onError || ((error) => console.error(\"Error:\", error));\n    this.onOpen = options.onOpen || (() => console.log(\"Connection opened\"));\n    this.onClose = options.onClose || (() => console.log(\"Connection closed\"));\n\n    // Initialize the SSE transport with headers\n    this.transport = new SSEClientTransport(this.serverUrl, this.headers);\n\n    // Initialize the client\n    this.client = new Client({\n      name: \"cpk-mcp-client\",\n      version: \"0.0.1\",\n    });\n\n    // Set up event handlers\n    this.transport.onmessage = this.handleMessage.bind(this);\n    this.transport.onerror = this.handleError.bind(this);\n    this.transport.onclose = this.handleClose.bind(this);\n  }\n\n  private handleMessage(message: JSONRPCMessage): void {\n    try {\n      this.onMessage(message as Record<string, unknown>);\n    } catch (error) {\n      this.onError(\n        error instanceof Error\n          ? error\n          : new Error(`Failed to handle message: ${error}`)\n      );\n    }\n  }\n\n  private handleError(error: Error): void {\n    this.onError(error);\n    if (this.isConnected) {\n      this.isConnected = false;\n      // Could implement reconnection logic here\n    }\n  }\n\n  private handleClose(): void {\n    this.isConnected = false;\n    this.onClose();\n  }\n\n  /**\n   * Connects to the MCP server using SSE\n   */\n  public async connect(): Promise<void> {\n    try {\n      console.log(\"Connecting to MCP server:\", this.serverUrl.href);\n\n      // Connect the client (which connects the transport)\n      await this.client.connect(this.transport);\n\n      this.isConnected = true;\n      console.log(\"Connected to MCP server\");\n      this.onOpen();\n    } catch (error) {\n      console.error(\"Failed to connect to MCP server:\", error);\n      this.onError(error instanceof Error ? error : new Error(String(error)));\n      throw error;\n    }\n  }\n\n  /**\n   * Returns a map of tool names to MCPTool objects\n   * This method matches the expected CopilotKit interface\n   */\n  public async tools(): Promise<Record<string, MCPTool>> {\n    try {\n      // Return from cache if available\n      if (this.toolsCache) {\n        return this.toolsCache;\n      }\n\n      // Fetch raw tools data\n      const rawToolsResult = await this.client.listTools();\n\n      // Transform to the expected format\n      const toolsMap: Record<string, MCPTool> = {};\n\n      if (rawToolsResult) {\n        // If the result has a 'tools' property with an array of tools\n        if (\n          typeof rawToolsResult === \"object\" &&\n          \"tools\" in rawToolsResult &&\n          Array.isArray(rawToolsResult.tools)\n        ) {\n          rawToolsResult.tools.forEach((tool: any) => {\n            if (tool && typeof tool === \"object\" && \"name\" in tool) {\n              // Extract required parameters if available\n              let requiredParams: string[] = [];\n\n              if (\n                tool.inputSchema &&\n                typeof tool.inputSchema === \"object\" &&\n                \"required\" in tool.inputSchema &&\n                Array.isArray(tool.inputSchema.required)\n              ) {\n                requiredParams = tool.inputSchema.required;\n              }\n\n              // Enhanced description with parameter requirements if available\n              let enhancedDescription = tool.description || \"\";\n\n              // Add parameter information to the description\n              if (requiredParams.length > 0) {\n                enhancedDescription += `\\nRequired parameters: ${requiredParams.join(\n                  \", \"\n                )}`;\n              }\n\n              // Add example structure if we can derive it from schema\n              const exampleInput = this.deriveExampleInput(\n                tool.inputSchema,\n                tool.name\n              );\n              if (exampleInput) {\n                enhancedDescription += `\\nExample usage: ${exampleInput}`;\n              }\n\n              toolsMap[tool.name] = {\n                description: enhancedDescription,\n                schema: tool.inputSchema || {},\n                execute: async (args: Record<string, unknown>) => {\n                  return this.callTool(tool.name, args);\n                },\n              };\n            }\n          });\n        }\n        // If the result is an array directly\n        else if (Array.isArray(rawToolsResult)) {\n          rawToolsResult.forEach((tool: any) => {\n            if (tool && typeof tool === \"object\" && \"name\" in tool) {\n              // Extract required parameters if available\n              let requiredParams: string[] = [];\n\n              if (\n                tool.inputSchema &&\n                typeof tool.inputSchema === \"object\" &&\n                \"required\" in tool.inputSchema &&\n                Array.isArray(tool.inputSchema.required)\n              ) {\n                requiredParams = tool.inputSchema.required;\n              }\n\n              // Enhanced description with parameter requirements if available\n              let enhancedDescription = tool.description || \"\";\n\n              // Add parameter information to the description\n              if (requiredParams.length > 0) {\n                enhancedDescription += `\\nRequired parameters: ${requiredParams.join(\n                  \", \"\n                )}`;\n              }\n\n              // Add example structure if we can derive it from schema\n              const exampleInput = this.deriveExampleInput(\n                tool.inputSchema,\n                tool.name\n              );\n              if (exampleInput) {\n                enhancedDescription += `\\nExample usage: ${exampleInput}`;\n              }\n\n              toolsMap[tool.name] = {\n                description: enhancedDescription,\n                schema: tool.inputSchema || {},\n                execute: async (args: Record<string, unknown>) => {\n                  return this.callTool(tool.name, args);\n                },\n              };\n            }\n          });\n        }\n      }\n\n      // Cache the result\n      this.toolsCache = toolsMap;\n\n      return toolsMap;\n    } catch (error) {\n      console.error(\"Error fetching tools:\", error);\n      // Return empty map on error rather than throwing\n      return {};\n    }\n  }\n\n  /**\n   * Close the connection to the MCP server\n   * This method matches the expected CopilotKit interface\n   */\n  public async close(): Promise<void> {\n    return this.disconnect();\n  }\n\n  /**\n   * Disconnects from the MCP server\n   * (Legacy method, prefer using close() for compatibility with CopilotKit)\n   */\n  public async disconnect(): Promise<void> {\n    try {\n      // Clear the tools cache\n      this.toolsCache = null;\n\n      // Close the transport connection\n      await this.transport.close();\n      this.isConnected = false;\n      console.log(\"Disconnected from MCP server\");\n    } catch (error) {\n      console.error(\"Error disconnecting from MCP server:\", error);\n      this.onError(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  /**\n   * Call a tool with the given name and arguments\n   * @param name Tool name\n   * @param args Tool arguments\n   * @returns Tool execution result\n   */\n  public async callTool(\n    name: string,\n    args: Record<string, unknown>\n  ): Promise<any> {\n    try {\n      console.log(\n        `Calling tool: ${name} with args:`,\n        JSON.stringify(args, null, 2)\n      );\n\n      // Generic handler for double-nested params structure\n      const fixedArgs = this.normalizeToolArgs(args);\n\n      // Process string-encoded JSON objects\n      const processedArgs = this.processStringifiedJsonArgs(fixedArgs);\n\n      // Log the processed arguments\n      console.log(\n        `Processed args for ${name}:`,\n        JSON.stringify(processedArgs, null, 2)\n      );\n\n      // Call the tool with processed arguments\n      return this.client.callTool({\n        name: name,\n        arguments: processedArgs,\n      });\n    } catch (error) {\n      console.error(`Error calling tool ${name}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Normalize tool arguments - detects and fixes common patterns in LLM tool calls\n   * like double-nested params objects\n   */\n  private normalizeToolArgs(\n    args: Record<string, unknown>\n  ): Record<string, unknown> {\n    // Handle double-nested params: { params: { params: { actual data } } }\n    if (\n      \"params\" in args &&\n      args.params !== null &&\n      typeof args.params === \"object\"\n    ) {\n      const paramsObj = args.params as Record<string, unknown>;\n      if (\"params\" in paramsObj) {\n        console.log(\"Detected double-nested params, fixing structure\");\n        return paramsObj;\n      }\n    }\n\n    return args;\n  }\n\n  /**\n   * Process arguments to handle cases where JSON strings might be passed instead of objects\n   */\n  private processStringifiedJsonArgs(\n    args: Record<string, unknown>\n  ): Record<string, unknown> {\n    const result: Record<string, unknown> = {};\n\n    // Process each argument to handle potential JSON strings\n    for (const [key, value] of Object.entries(args)) {\n      if (typeof value === \"string\") {\n        // Try to parse potential JSON strings\n        try {\n          const parsedValue = JSON.parse(value);\n          result[key] = parsedValue;\n        } catch (e) {\n          // Not valid JSON, keep as string\n          result[key] = value;\n        }\n      } else if (Array.isArray(value)) {\n        // Preserve arrays properly\n        result[key] = value.map((item) =>\n          typeof item === \"object\" && item !== null\n            ? this.processStringifiedJsonArgs(item as Record<string, unknown>)\n            : item\n        );\n      } else if (value !== null && typeof value === \"object\") {\n        // Recursively process nested objects\n        result[key] = this.processStringifiedJsonArgs(\n          value as Record<string, unknown>\n        );\n      } else {\n        // Keep other types as-is\n        result[key] = value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Derives an example input structure from a tool's inputSchema\n   * This helps the LLM understand how to format requests properly\n   */\n  private deriveExampleInput(\n    inputSchema: any,\n    toolName: string\n  ): string | null {\n    if (!inputSchema) return null;\n\n    try {\n      // Handle special cases for better guidance\n      if (toolName.toLowerCase().includes(\"asana_create\")) {\n        return '{ \"params\": { \"data\": { \"name\": \"Task name\", \"notes\": \"Task description\" } } }';\n      }\n\n      if (inputSchema.type === \"object\" && inputSchema.properties) {\n        // Build a minimal example object\n        const example: Record<string, any> = {};\n        const props = inputSchema.properties;\n\n        // Add required properties first\n        if (Array.isArray(inputSchema.required)) {\n          inputSchema.required.forEach((key: string) => {\n            if (key in props) {\n              if (props[key].type === \"object\" && props[key].properties) {\n                example[key] = this.createExampleObject(props[key]);\n              } else if (props[key].type === \"string\") {\n                example[key] = `\"Example ${key}\"`;\n              } else if (props[key].type === \"number\") {\n                example[key] = 123;\n              } else if (props[key].type === \"boolean\") {\n                example[key] = true;\n              } else {\n                example[key] = null;\n              }\n            }\n          });\n        }\n\n        return JSON.stringify(example, null, 2);\n      }\n\n      return null;\n    } catch (error) {\n      console.error(\"Error creating example input:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Creates an example object from an object schema\n   */\n  private createExampleObject(schema: any): Record<string, any> {\n    const result: Record<string, any> = {};\n\n    if (schema.type !== \"object\" || !schema.properties) {\n      return result;\n    }\n\n    const props = schema.properties;\n\n    // Add required properties\n    if (Array.isArray(schema.required)) {\n      schema.required.forEach((key: string) => {\n        if (key in props) {\n          if (props[key].type === \"object\" && props[key].properties) {\n            result[key] = this.createExampleObject(props[key]);\n          } else if (props[key].type === \"string\") {\n            result[key] = `Example ${key}`;\n          } else if (props[key].type === \"number\") {\n            result[key] = 123;\n          } else if (props[key].type === \"boolean\") {\n            result[key] = true;\n          } else {\n            result[key] = null;\n          }\n        }\n      });\n    }\n\n    return result;\n  }\n}\n",
      "type": "registry:lib",
      "target": "app/utils/mcp-client.ts"
    }
  ]
}