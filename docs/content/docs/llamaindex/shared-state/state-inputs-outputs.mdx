---
title: Agent state inputs and outputs
icon: "lucide/ArrowRightLeft"
description: Decide which state properties are received and returned to the frontend.
---

## What is this?

Not all state properties are relevant for frontend-backend sharing.
This guide shows how to ensure only the right portion of state is communicated back and forth.

## When should I use this?

Depending on your implementation, some properties are meant to be processed internally, while some others are the way for the UI to communicate user input.
In addition, some state properties contain a lot of information. Syncing them back and forth between the agent and UI can be costly, while it might not have any practical benefit.

## Implementation

<Steps>
  <Step>
    ### Examine your state structure
    LlamaIndex agents using the AG-UI workflow router are stateful. As you execute tools and process messages, that state is updated and available throughout the session. For this example,
    let's assume that the state our agent should be using can be described like this:

    ```python title="agent.py"
    # Full state structure for the agent
    initial_state = {
        "question": "",         # Input from user
        "answer": "",           # Output to user
        "resources": []         # Internal use only
    }
    ```
  </Step>
  <Step>
    ### Organize state by purpose
    Our example case lists several state properties, each with its own purpose:
      - The **question** is being asked by the user, expecting the LLM to answer
      - The **answer** is what the LLM returns
      - The **resources** list will be used by the LLM to answer the question, and should not be communicated to the user, or set by them

    Here's a complete example showing how to structure your agent with these considerations:

    ```python title="agent.py"
    from typing import Annotated, List
    from llama_index.llms.openai import OpenAI
    from llama_index.protocols.ag_ui.router import get_ag_ui_workflow_router
    from fastapi import FastAPI


    def answer_question(
        answer: Annotated[str, "The answer to store in state."]
    ) -> str:
        """Stores the answer to the user's question.

        Args:
            answer: The answer to store in state.

        Returns:
            str: A message indicating the answer was stored.
        """
        return f"Answer stored: {answer}"


    def add_resource(
        resource: Annotated[str, "The resource URL or reference to add."]
    ) -> str:
        """Adds a resource to the internal resources list.

        Args:
            resource: The resource URL or reference to add.

        Returns:
            str: A message indicating the resource was added.
        """
        return f"Resource added: {resource}"


    agentic_chat_router = get_ag_ui_workflow_router(
        llm=OpenAI(model="gpt-4o"),
        system_prompt="""
        You are a helpful assistant. When answering questions:
        1. Use add_resource to track any sources you reference (internal use)
        2. Use answer_question to provide your final answer to the user
        
        The question from the user is available in state as 'question'.
        """,
        backend_tools=[answer_question, add_resource],
        initial_state={
            "question": "",       # Input: received from frontend
            "answer": "",         # Output: sent to frontend
            "resources": []       # Internal: not shared with frontend
        },
    )

    app = FastAPI()
    app.include_router(agentic_chat_router)

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```
  </Step>
  <Step>
    ### Use the state in your frontend
    Now that we know which state properties our agent uses, we can work with them in the UI:
    - **question**: Set by the UI to ask the agent something
    - **answer**: Read from the agent's response
    - **resources**: Not accessible to the UI (internal agent use only)

    ```tsx title="ui/app/page.tsx"
    "use client";
    
    import { useCoAgent } from "@copilotkit/react-core";

    // Only define the types for state you'll interact with
    type AgentState = {
      question: string;
      answer: string;
      // Note: 'resources' is intentionally omitted - it's internal to the agent
    }

    function YourMainContent() {
      const { state, setState } = useCoAgent<AgentState>({
        name: "my_agent",
        initialState: {
          question: "How's the weather in SF?",
          answer: "",
        }
      });

      const askQuestion = (newQuestion: string) => {
        setState({ ...state, question: newQuestion });
      };

      return (
        <div>
          <h1>Q&A Assistant</h1>
          <p><strong>Question:</strong> {state.question}</p>
          <p><strong>Answer:</strong> {state.answer || "Waiting for response..."}</p>
          <button onClick={() => askQuestion("What's the capital of France?")}>
            Ask New Question
          </button>
        </div>
      );
    }
    ```

    <Callout type="warn" title="Important">
      The `name` parameter must exactly match the agent name you defined in your CopilotRuntime configuration (e.g., `my_agent` from the quickstart).
    </Callout>
  </Step>
  <Step>
    ### Give it a try!
    Now that we've organized state by purpose:
    - The UI can set `question` and read `answer`
    - The agent uses `resources` internally without exposing it to the frontend
    - State updates flow efficiently between frontend and backend
  </Step>
</Steps>

