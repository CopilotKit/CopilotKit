---
title: Agentic Generative UI
icon: "lucide/Bot"
description: Render the state of your agent with custom UI components.
---

import { Accordions, Accordion } from "fumadocs-ui/components/accordion";

<video
  src="https://cdn.copilotkit.ai/docs/copilotkit/images/coagents/agentic-generative-ui.mp4"
  className="rounded-lg shadow-xl"
  loop
  playsInline
  controls
  autoPlay
  muted
/>

## What is this?

All ADK agents are stateful. This means that as your agent progresses through nodes, a state object is passed between them perserving
the overall state of a session. CopilotKit allows you to render this state in your application with custom UI components, which we call **Agentic Generative UI**.

## When should I use this?

Rendering the state of your agent in the UI is useful when you want to provide the user with feedback about the overall state of a session. A great example of this
is a situation where a user and an agent are working together to solve a problem. The agent can store a draft in its state which is then rendered in the UI.

## Implementation

<Steps>
  <Step>
    ### Run and Connect your ADK Agent to CopilotKit
    First, you'll need to make sure you have a running ADK Agent. If you haven't already done this, you can follow the [Getting Started Guide](/adk/quickstart/adk)

  </Step>
  <Step>
    ### Define your agent state
    If you're not familiar with ADK, your agents are stateful. As you progress through function, a state object is updated between them. CopilotKit
    allows you to easily render this state in your application.

    For the sake of this guide, let's say our state looks like this in our agent.

    <Tabs groupId="language" items={['Python']} default="Python">
        <Tab value="Python">
          ```python title="agent-py/sample_agent/agent.py"
          class SomeAgentState(BaseModel):
            """State for the agent."""

            language: str = "english"
          ```
        </Tab>
    </Tabs>

  </Step>
  <Step>
    ### Simulate state updates
    Next, let's write some logic into our agent that will simulate state updates occurring.

    <Tabs groupId="language" items={['Python']} default="Python">
      <Tab value="Python">
        ```python title="agent-py/sample_agent/agent.py"
        import json
        from typing import Dict, Optional
        from fastapi import FastAPI
        from ag_ui_adk import ADKAgent, add_adk_fastapi_endpoint

        # ADK imports
        from google.adk.agents import LlmAgent
        from google.adk.agents.callback_context import CallbackContext
        from google.adk.tools import ToolContext
        from google.adk.models import LlmResponse, LlmRequest
        from google.genai import types

        from pydantic import BaseModel
        from typing import List, Optional
        from enum import Enum


        class SomeAgentState(BaseModel):
            """State for the agent."""

            language: str = "english"


        def set_language(tool_context: ToolContext, new_language: str) -> Dict[str, str]:
            """
            Set the language

            Args:
                "new_language": {
                    "type": "string",
                    "description": "The language to be saved in state",
                }

            Returns:
                Dict indicating success status and message
            """
            try:
                # Put this into a state object just to confirm the shape
                new_state = {"language": new_language}
                tool_context.state["language"] = new_state["language"]
                return {"status": "success", "message": "language updated successfully"}

            except Exception as e:
                return {"status": "error", "message": f"Error updating language: {str(e)}"}


        def on_before_agent(callback_context: CallbackContext):
            """
            Initialize agent state if it doesn't exist.
            """
            if "language" not in callback_context.state:
                # Initialize with default recipe
                default_agent_state = {"language": "english"}
                callback_context.state["language"] = default_agent_state["language"]

            return None


        # --- Define the Callback Function ---
        #  modifying the agent's system prompt to incude the current state of recipe
        def before_model_modifier(
            callback_context: CallbackContext, llm_request: LlmRequest
        ) -> Optional[LlmResponse]:
            """Inspects/modifies the LLM request or skips the call."""
            agent_name = callback_context.agent_name
            if agent_name == "assistant":
                language_json = "No language yet"
                if (
                    "language" in callback_context.state
                    and callback_context.state["language"] is not None
                ):
                    try:
                        language_json = json.dumps(callback_context.state["language"], indent=2)
                    except Exception as e:
                        language_json = f"Error serializing language: {str(e)}"
                # --- Modification Example ---
                # Add a prefix to the system instruction
                original_instruction = llm_request.config.system_instruction or types.Content(
                    role="system", parts=[]
                )
                prefix = f"""
        You are a helpful assistant
        This is the current state of the language choice: {language_json}"""
                # Ensure system_instruction is Content and parts list exists
                if not isinstance(original_instruction, types.Content):
                    # Handle case where it might be a string (though config expects Content)
                    original_instruction = types.Content(
                        role="system", parts=[types.Part(text=str(original_instruction))]
                    )
                if not original_instruction.parts:
                    original_instruction.parts.append(
                        types.Part(text="")
                    )  # Add an empty part if none exist

                # Modify the text of the first part
                modified_text = prefix + (original_instruction.parts[0].text or "")
                original_instruction.parts[0].text = modified_text
                llm_request.config.system_instruction = original_instruction

            return None


        sample_agent = LlmAgent(
            name="assistant",
            model="gemini-2.5-flash",
            instruction="""
            You are a helpful assistant. Help users by answering their questions and assisting with their needs.
            """,
            tools=[set_language],
            before_agent_callback=on_before_agent,
            before_model_callback=before_model_modifier,
        )

        # Create ADK middleware agent instance
        adk_sample_agent = ADKAgent(
            adk_agent=sample_agent,
            app_name="sample_agent",
            user_id="demo_user",
            session_timeout_seconds=3600,
            use_in_memory_services=True,
        )

        # Create FastAPI app
        app = FastAPI(title="ADK Middleware Agentic Generative UI Sample Agent")

        # Add the ADK endpoint
        add_adk_fastapi_endpoint(app, adk_sample_agent, path="/")

        if __name__ == "__main__":
            import os
            import uvicorn

            port = int(os.getenv("PORT", 8000))
            uvicorn.run(app, host="0.0.0.0", port=port)
        ```
      </Tab>
    </Tabs>

  </Step>
  <Step>
    ### Render state of the agent in the chat
    Now we can utilize `useCoAgentStateRender` to render the state of our agent **in the chat**.

    ```tsx title="app/page.tsx"
    // ...
    import { useCoAgent, useCoAgentStateRender } from "@copilotkit/react-core";
    // ...

    // Define the state of the agent, should match the state of the agent in your Flow.
    type AgentState = {
      language: string;
    };

    function YourMainContent() {
      // ...

      // styles omitted for brevity
      // [!code highlight:8]
      useCoAgentStateRender<AgentState>({
        name: "sample_agent", // the name the agent is served as
        render: ({ state }) => (
          <div>
            the current language is {state.language || 'not set'}
          </div>
        ),
      });

      // ...

      return <div>...</div>;
    }
    ```

  </Step>
  <Step>
    ### Render state outside of the chat
    You can also render the state of your agent **outside of the chat**. This is useful when you want to render the state of your agent anywhere
    other than the chat.

    ```tsx title="app/page.tsx"
    import { useCoAgent } from "@copilotkit/react-core"; // [!code highlight]
    // ...

    // Define the state of the agent, should match the state of the agent in your Flow.
    type AgentState = {
      language: string;
    };

    function YourMainContent() {
      // ...

      // [!code highlight:3]
      const { state } = useCoAgent<AgentState>({
        name: "sample_agent", // the name the agent is served as
      })

      // ...

      return (
        <div>
          {/* ... */}
          <div className="flex flex-col gap-2 mt-4">
            {/* [!code state:run:1] */}
            the current language is {state.language || 'not set'}
          </div>
        </div>
      )
    }
    ```

  </Step>
  <Step>
    ### Give it a try!

    You've now created a component that will render the agent's state in the chat.

  </Step>
</Steps>
