---
title: "Emitting messages imperatively"
---

Most Agentic Copilot interactions will be controlled by the LLM, guided by messages the user and your agent code add to its stack via shared state. While state is synced with the frontend regularly as the agent traverses nodes on its workflow graph, occasionally you will want to imperatively send text or JSON-based messages from within an agent method as a way to give the user more immediate feedback.

## Emitting text-based messages

In your agent's workflow, you'll want to ask the user specific questions or prompt them for specific input. The `copilotkit_emit_message` method allows you to inject messages into the conversation as if they had been generated by the LLM, and the user's response will trigger the appropriate next step in the graph.

```python filename="agent.py"
async def ask_name_node(state: GreetAgentState, config: RunnableConfig):
    """
    Ask the user for their name.
    """

    await copilotkit_emit_message(config, "Hey, what is your name? üôÇ")

    return {
        "messages": state["messages"],
    }
```

`copilotkit_emit_message` is also useful when formatting a response to the user after a request has been completed:

```python
if last_message.content == "CANCEL":
    await copilotkit_emit_message(config, "‚ùå Cancelled sending email.")
else:
    await copilotkit_emit_message(config, "‚úÖ Sent email.")
```

{/* ## Emitting JSON and tool calls

TKTK */}

## Manually emitting state

While LangGraph will emit the current agent state after each node in the workflow graph, sometimes you will need to update your UI while a task is still being worked on so the user has visibility into what's going on. The `copilot_emit_state` method will send the current state to the frontend at any point during an agent run:

```python filename="agent.py"
async def download_node(state: AgentState, config: RunnableConfig):
    """
    Download resources from the internet.
    """
    state["resources"] = state.get("resources", [])
    state["logs"] = state.get("logs", [])
    resources_to_download = []

    logs_offset = len(state["logs"])

    # Find resources that are not downloaded
    for resource in state["resources"]:
        if not get_resource(resource["url"]):
            resources_to_download.append(resource)
            state["logs"].append({
                "message": f"Downloading {resource['url']}",
                "done": False
            })

    # Emit the state to let the UI update
    await copilotkit_emit_state(config, state)

    # Download the resources
    for i, resource in enumerate(resources_to_download):
        await _download_resource(resource["url"])
        state["logs"][logs_offset + i]["done"] = True

        # update UI
        await copilotkit_emit_state(config, state)

    return state
```