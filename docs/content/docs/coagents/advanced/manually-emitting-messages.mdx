---
title: "Emitting messages imperatively"
---

Most CoAgent interactions will be controlled by the LLM, guided by messages the user and your agent code add to its stack via shared state. While state is synced with the frontend regularly as the agent traverses nodes on its workflow graph, occasionally you will want to imperatively send text or JSON-based messages from within an agent method as a way to give the user more immediate feedback.

## Emitting text-based messages

In your agent's workflow, you'll want to ask the user specific questions or prompt them for specific input. The `copilotkit_emit_message` method allows you to inject messages into the conversation as if they had been generated by the LLM, and the user's response will trigger the appropriate next step in the graph.

<Tabs items={['Python', 'TypeScript']} default="Python">
    <Tab value="Python">
        ```python
        async def ask_name_node(state: GreetAgentState, config: RunnableConfig):
            """
            Ask the user for their name.
            """

            await copilotkit_emit_message(config, "Hey, what is your name? üôÇ")

            return {
                "messages": state["messages"],
            }
        ```
    </Tab>
    <Tab value="TypeScript">
        ```typescript
        async function askNameNode(state: GreetAgentState, config: RunnableConfig): Promise<AgentState> {
            /**
             * Ask the user for their name.
             */

            await copilotKitEmitMessage(config, "Hey, what is your name? üôÇ");

            return {
                messages: state.messages,
            };
        }
        ```
    </Tab>
</Tabs>

`copilotkit_emit_message` is also useful when formatting a response to the user after a request has been completed:

<Tabs items={['Python', 'TypeScript']} default="Python">
    <Tab value="Python">
        ```python
        if last_message.content == "CANCEL":
            await copilotkit_emit_message(config, "‚ùå Cancelled sending email.")
        else:
            await copilotkit_emit_message(config, "‚úÖ Sent email.")
        ```
    </Tab>
    <Tab value="TypeScript">
        ```typescript
        if (lastMessage.content === "CANCEL") {
            await copilotKitEmitMessage(config, "‚ùå Cancelled sending email.");
        } else {
            await copilotKitEmitMessage(config, "‚úÖ Sent email.");
        }
        ```
    </Tab>
</Tabs>

{/* ## Emitting JSON and tool calls

TKTK */}

## Manually emitting state

While LangGraph will emit the current agent state after each node in the workflow graph, sometimes you will need to update your UI while a task is still being worked on so the user has visibility into what's going on. The `copilot_emit_state` method will send the current state to the frontend at any point during an agent run:

<Tabs items={['Python', 'TypeScript']} default="Python">
    <Tab value="Python">
        ```python
        async def download_node(state: AgentState, config: RunnableConfig):
            """
            Download resources from the internet.
            """
            state["resources"] = state.get("resources", [])
            state["logs"] = state.get("logs", [])
            resources_to_download = []

            logs_offset = len(state["logs"])

            # Find resources that are not downloaded
            for resource in state["resources"]:
                if not get_resource(resource["url"]):
                    resources_to_download.append(resource)
                    state["logs"].append({
                        "message": f"Downloading {resource['url']}",
                        "done": False
                    })

            # Emit the state to let the UI update
            await copilotkit_emit_state(config, state)

            # Download the resources
            for i, resource in enumerate(resources_to_download):
                await _download_resource(resource["url"])
                state["logs"][logs_offset + i]["done"] = True

                # update UI
                await copilotkit_emit_state(config, state)

            return state
        ```
    </Tab>
    <Tab value="TypeScript">
        ```typescript
        async function downloadNode(state: AgentState, config: RunnableConfig): Promise<AgentState> {
            /**
             * Download resources from the internet.
             */
            state.resources = state.resources || [];
            state.logs = state.logs || [];
            const resourcesToDownload = [];

            const logsOffset = state.logs.length;

            // Find resources that are not downloaded
            for (const resource of state.resources) {
                if (!getResource(resource.url)) {
                    resourcesToDownload.push(resource);
                    state.logs.push({
                        message: `Downloading ${resource.url}`,
                        done: false
                    });
                }
            }

            // Emit the state to let the UI update
            await copilotKitEmitState(config, state);

            // Download the resources
            for (let i = 0; i < resourcesToDownload.length; i++) {
                const resource = resourcesToDownload[i];
                await _downloadResource(resource.url);
                state.logs[logsOffset + i].done = true;

                // update UI
                await copilotKitEmitState(config, state);
            }

            return state;
        }
        ```
    </Tab>
</Tabs>