---
title: "Using Agent Execution Parameters"
icon: "lucide/Bolt"
description: "Using agent execution parameters when communicating with an agent."
---

## What is this?

Microsoft Agent Framework agents can receive runtime configuration and parameters through CopilotKit's `properties` prop, which are forwarded to your AG-UI server via the `forwardedProps` parameter.

## When should I use this?

This is useful when you want to send execution-time configuration information (such as different tokens or metadata for a given session) that should not be part of the agent state.

## Implementation

<Steps>
<Step>
### Pass properties from the frontend

Pass configuration via CopilotKit's `properties` prop:

```tsx title="app/page.tsx"
import { CopilotKit } from "@copilotkit/react-core";

function YourApp() {
  const userToken = getUserToken(); // Your auth logic
  const userId = getUserId(); // Your user logic

  return (
    <CopilotKit
      runtimeUrl="/api/copilotkit"
      properties={{
        // [!code highlight:4]
        authToken: userToken,
        userId: userId,
        userPreferences: { theme: 'dark', language: 'en' }
      }}
    >
      <YourMainContent />
    </CopilotKit>
  );
}
```

<Callout type="info">
  Properties passed to `<CopilotKit>` are forwarded to your AG-UI server via the `forwardedProps` parameter.
</Callout>
</Step>
<Step>
### Access properties in your AG-UI server

Retrieve the forwarded properties in your AG-UI handler:

```csharp title="Program.cs"
using Azure.AI.OpenAI;
using Azure.Identity;
using Microsoft.Agents.AI;
using Microsoft.Agents.AI.Hosting.AGUI.AspNetCore;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

string endpoint = builder.Configuration["AZURE_OPENAI_ENDPOINT"]!;
string deployment = builder.Configuration["AZURE_OPENAI_DEPLOYMENT_NAME"]!;

app.MapAGUIAgent("/", (messages, tools, context, forwardedProps) =>
{
    // [!code highlight:6]
    // Extract configuration from forwardedProps
    var authToken = forwardedProps?.GetValueOrDefault("authToken")?.ToString();
    var userId = forwardedProps?.GetValueOrDefault("userId")?.ToString();
    var preferences = forwardedProps?.GetValueOrDefault("userPreferences");
    
    // Validate auth token if needed
    // if (string.IsNullOrEmpty(authToken)) throw new UnauthorizedAccessException();
    
    // Customize agent based on configuration
    var instructions = $"You are a helpful assistant for user {userId}. Adapt responses based on user preferences.";
    
    var client = new AzureOpenAIClient(new Uri(endpoint), new DefaultAzureCredential());
    var agent = client.GetChatClient(deployment)
        .CreateAIAgent(
            name: "PersonalizedAgent",
            instructions: instructions
        );
    
    return agent;
});

await app.RunAsync();
```
</Step>
<Step>
### Use configuration in agent tools

You can also use the configuration to customize tool behavior. Store configuration in a service and inject it into your tools:

```csharp
// Register configuration as a singleton
builder.Services.AddSingleton(new AgentConfiguration 
{ 
    UserId = "default" 
});

app.MapAGUIAgent("/", (messages, tools, context, forwardedProps) =>
{
    // Update configuration based on forwarded props
    var userId = forwardedProps?.GetValueOrDefault("userId")?.ToString();
    
    // Your tools can access this via dependency injection
    // and customize behavior per user
    
    var client = new AzureOpenAIClient(new Uri(endpoint), new DefaultAzureCredential());
    var agent = client.GetChatClient(deployment)
        .CreateAIAgent(name: "ConfigurableAgent");
    
    return agent;
});
```
</Step>
</Steps>
