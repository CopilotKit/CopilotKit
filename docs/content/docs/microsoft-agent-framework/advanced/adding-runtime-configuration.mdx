---
title: "Using Agent Execution Parameters"
icon: "lucide/Bolt"
description: "Using agent execution parameters when communicating with an agent."
---

## What is this?

Microsoft Agent Framework agents can receive runtime configuration and parameters through CopilotKit's `properties` prop, which are forwarded to your AG-UI server via the `forwardedProps` parameter.

## When should I use this?

This is useful when you want to send execution-time configuration information (such as different tokens or metadata for a given session) that should not be part of the agent state.

## Implementation

<Steps>
<Step>
### Pass headers from the frontend

Pass configuration via CopilotKit's `headers` prop:

```tsx title="app/page.tsx"
import { CopilotKit } from "@copilotkit/react-core";

function YourApp() {
  const userToken = getUserToken(); // Your auth logic
  const userId = getUserId(); // Your user logic

  return (
    <CopilotKit
      runtimeUrl="/api/copilotkit"
      headers={{
        // [!code highlight:4]
        Authorization: `Bearer ${userToken}`,
        "X-User-Id": userId,
        "X-User-Preferences": JSON.stringify({ theme: 'dark', language: 'en' })
      }}
    >
      <YourMainContent />
    </CopilotKit>
  );
}
```

<Callout type="info">
  Headers passed to `<CopilotKit>` are forwarded to your Copilot Runtime and then to your AG-UI server, where you can access them via `HttpContext.Request.Headers`.
</Callout>
</Step>
<Step>
### Access headers in your AG-UI server

Retrieve the forwarded headers in your AG-UI handler via `HttpContext`:

```csharp title="Program.cs"
using AGUI;
using Azure.AI.OpenAI;
using Azure.Identity;
using Microsoft.Agents.AI;
using Microsoft.Agents.AI.AGUI;
using Microsoft.Agents.AI.Hosting.AGUI.AspNetCore;

var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

string endpoint = builder.Configuration["AZURE_OPENAI_ENDPOINT"]!;
string deployment = builder.Configuration["AZURE_OPENAI_DEPLOYMENT_NAME"]!;

app.MapAGUIAgent("/", (RunAgentInput agentInput, HttpContext context) =>
{
    // [!code highlight:6]
    // Extract configuration from request headers
    var authToken = context.Request.Headers["Authorization"].FirstOrDefault();
    var userId = context.Request.Headers["X-User-Id"].FirstOrDefault();
    var preferences = context.Request.Headers["X-User-Preferences"].FirstOrDefault();
    
    // Validate auth token if needed
    // if (string.IsNullOrEmpty(authToken)) throw new UnauthorizedAccessException();
    
    // Customize agent based on configuration
    var instructions = $"You are a helpful assistant for user {userId}. Adapt responses based on user preferences.";
    
    var client = new AzureOpenAIClient(new Uri(endpoint), new DefaultAzureCredential());
    var chatClient = client.GetChatClient(deployment).AsIChatClient();
    var agent = new ChatClientAgent(
        chatClient,
        name: "PersonalizedAgent",
        description: instructions
    );
    
    return new ChatClientAGUIAgent(agent);
});

await app.RunAsync();
```
</Step>
<Step>
### Use configuration in agent tools

You can also extract headers and store configuration in a service for use in your tools:

```csharp
// Register configuration service
builder.Services.AddScoped<UserConfiguration>();

app.MapAGUIAgent("/", (RunAgentInput agentInput, HttpContext context) =>
{
    // Extract user context from headers
    var userId = context.Request.Headers["X-User-Id"].FirstOrDefault();
    
    // Store in scoped service for tool access
    var userConfig = context.RequestServices.GetRequiredService<UserConfiguration>();
    userConfig.UserId = userId ?? "default";
    
    // Your tools can access UserConfiguration via dependency injection
    // and customize behavior per user
    
    var client = new AzureOpenAIClient(new Uri(endpoint), new DefaultAzureCredential());
    var chatClient = client.GetChatClient(deployment).AsIChatClient();
    var agent = new ChatClientAgent(chatClient, name: "ConfigurableAgent");
    
    return new ChatClientAGUIAgent(agent);
});
```
</Step>
</Steps>
