---
title: Agent state inputs and outputs
icon: "lucide/ArrowRightLeft"
description: Decide which state properties are sent to and received from the frontend
---

## What is this?

Not all state properties are relevant for frontend-backend sharing.
This guide shows how to ensure only the right portion of state is communicated back and forth.

This guide helps you design a UI-facing state contract for your agent when using CopilotKit with Microsoft Agent Framework.

## When should I use this?

Depending on your implementation, some properties are meant to be processed internally, while some others are the way for the UI to communicate user input.
In addition, some state properties contain a lot of information. Syncing them back and forth between the agent and UI can be costly, while it might not have any practical benefit.

## Implementation

<Steps>
  <Step>
      ### Examine our old state
      For this example, let's assume our agent maintains a few state properties. We'll keep the UI-facing contract minimal while allowing internal data on the server:

      ```csharp title="agent/Program.cs (excerpt)"
      // Full server-side snapshot (internal + UI-facing)
      public class OverallStateSnapshot
      {
          public string? Question { get; set; }
          public string? Answer { get; set; }
          public List<string> Resources { get; set; } = new(); // internal only
      }
      ```

      On the UI, we only need to read the question we set and the answer returned by the agent:
      ```typescript title="ui/app/page.tsx"
      type AgentState = {
        question?: string;
        answer?: string;
      }
      ```
  </Step>
  <Step>
    ### Divide state to Input and Output
    Our example case lists several state properties, each with its own purpose:
      - The question is being asked by the user, expecting the llm to answer
      - The answer is what the LLM returns
      - The resources list will be used by the LLM to answer the question, and should not be communicated to the user, or set by them.

      On the server, keep input/output vs internal data clear in your own snapshot types:

      ```csharp title="agent/Program.cs (excerpt)"
      // Inputs you are willing to accept from the frontend
      public class InputStateSnapshot
      {
          public string? Question { get; set; }
      }

      // Outputs you are willing to pass back to the frontend
      public class OutputStateSnapshot
      {
          public string? Answer { get; set; }
      }

      // Overall state held on the server (UI-facing + internal)
      public class OverallStateSnapshot : OutputStateSnapshot
      {
          public List<string> Resources { get; set; } = new(); // internal only
      }

      // Example AG-UI mapping (simplified)
      app.MapAGUIAgent("/", (input, http) =>
      {
          // input.Properties can include UI-provided values (e.g., question)
          var question = input.Properties?.GetValueOrDefault("question")?.ToString();

          var state = new OverallStateSnapshot
          {
              Answer = !string.IsNullOrWhiteSpace(question) ? $"Answer to: {question}" : null,
              Resources = new List<string> { "docA", "docB" } // internal
          };

          // Create and return your agent; ensure it surfaces only the output fields as needed
          var githubToken = http.RequestServices.GetRequiredService<IConfiguration>["GitHubToken"]!;
          var openAI = new OpenAI.OpenAIClient(
              new System.ClientModel.ApiKeyCredential(githubToken),
              new OpenAI.OpenAIClientOptions { Endpoint = new Uri("https://models.inference.ai.azure.com")});
          var chat = openAI.GetChatClient("gpt-4o-mini").AsIChatClient();
          var agent = new Microsoft.Agents.AI.ChatClientAgent(chat, name: "SampleAgent", description: "A helpful assistant.");
          return new Microsoft.Agents.AI.AGUI.ChatClientAGUIAgent(agent);
      });
      ```

      On the UI, read only the agreed contract:

      ```tsx
      import { useCoAgent } from "@copilotkit/react-core";

      const { state } = useCoAgent<AgentState>({
        name: "sample_agent",
        initialState: { question: "How's the weather in SF?" },
      });

      console.log(state);
      // Expect the UI to set "question" and the agent to return "answer"
      ```
  </Step>
  <Step>
    ### Give it a try!
    Now that we know which state properties our agent emits, we can inspect the state and expect the following to happen:
    - While we are able to provide a question, we will not receive it back from the agent. If we are using it in our UI, we need to remember the UI is the source of truth for it
    - Answer will change once it's returned back from the agent
    - The UI has no access to resources.

    ```tsx
    import { useCoAgent } from "@copilotkit/react-core";

    type AgentState = {
      question: string;
      answer: string;
    }

    const { state } = useCoAgent<AgentState>({
      name: "sample_agent",
      initialState: {
        question: "How's is the weather in SF?",
      }
    });

    console.log(state) // You can expect seeing "answer" change, while the others are not returned from the agent
    ```
  </Step>
</Steps>
